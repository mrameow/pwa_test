<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Pinch Drawing</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body {
            background-color: #111;
            color: white;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Container ensures video and canvas overlap perfectly */
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        /* Mirror the output for natural interaction */
        .mirrored {
            transform: scaleX(-1);
        }

        canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* UI Overlay should not be mirrored */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to hidden controls if needed */
            z-index: 50;
        }

        .interactive-panel {
            pointer-events: auto;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <!-- Hidden Video Element for MediaPipe input -->
    <video id="input_video" class="hidden"></video>

    <!-- Main Container -->
    <div id="canvas-container">
        <!-- The Canvas where we draw video + AR lines -->
        <canvas id="output_canvas" class="mirrored"></canvas>
        
        <!-- UI Overlay -->
        <div id="ui-layer" class="flex flex-col justify-between p-4">
            
            <!-- Header / Status -->
            <div class="flex justify-between items-start">
                <div class="bg-black/60 backdrop-blur-md p-4 rounded-xl border border-white/10 shadow-xl">
                    <h1 class="text-2xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">AR Paint</h1>
                    <div id="status-indicator" class="flex items-center gap-2 mt-1">
                        <div class="loader w-4 h-4 border-2"></div>
                        <span class="text-sm text-gray-300">Loading AI Model...</span>
                    </div>
                    <p class="text-xs text-gray-400 mt-2">Pinch thumb & index to draw.</p>
                </div>

                <!-- Preview of Brush (Top Right) -->
                <div class="bg-black/60 backdrop-blur-md p-3 rounded-full border border-white/10 shadow-xl">
                    <div id="brush-preview" class="w-8 h-8 rounded-full bg-white border-2 border-white transition-all duration-300"></div>
                </div>
            </div>

            <!-- Controls (Bottom) -->
            <div class="interactive-panel flex flex-col items-center gap-4 mb-4">
                
                <!-- Color Palette -->
                <div class="bg-black/70 backdrop-blur-md p-2 rounded-2xl flex gap-3 shadow-2xl border border-white/10">
                    <button onclick="setColor('#ef4444')" class="w-10 h-10 rounded-full bg-red-500 hover:scale-110 transition ring-2 ring-transparent focus:ring-white"></button>
                    <button onclick="setColor('#22c55e')" class="w-10 h-10 rounded-full bg-green-500 hover:scale-110 transition ring-2 ring-transparent focus:ring-white"></button>
                    <button onclick="setColor('#3b82f6')" class="w-10 h-10 rounded-full bg-blue-500 hover:scale-110 transition ring-2 ring-transparent focus:ring-white"></button>
                    <button onclick="setColor('#eab308')" class="w-10 h-10 rounded-full bg-yellow-500 hover:scale-110 transition ring-2 ring-transparent focus:ring-white"></button>
                    <button onclick="setColor('#a855f7')" class="w-10 h-10 rounded-full bg-purple-500 hover:scale-110 transition ring-2 ring-transparent focus:ring-white"></button>
                    <button onclick="setColor('#ffffff')" class="w-10 h-10 rounded-full bg-white hover:scale-110 transition ring-2 ring-transparent focus:ring-white"></button>
                    <button onclick="setColor('#000000')" class="w-10 h-10 rounded-full bg-black border border-gray-600 hover:scale-110 transition ring-2 ring-transparent focus:ring-white"></button>
                </div>

                <!-- Tools -->
                <div class="bg-black/70 backdrop-blur-md px-6 py-3 rounded-2xl flex items-center gap-6 shadow-2xl border border-white/10">
                    <div class="flex flex-col items-center">
                        <label class="text-xs text-gray-400 mb-1">Size</label>
                        <input type="range" min="1" max="30" value="5" class="w-32 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-blue-500" oninput="setLineWidth(this.value)">
                    </div>
                    
                    <div class="w-px h-10 bg-gray-600"></div>

                    <button onclick="clearCanvas()" class="flex items-center gap-2 text-white hover:text-red-400 transition">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path></svg>
                        <span>Clear</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusInd = document.getElementById('status-indicator');
        const brushPreview = document.getElementById('brush-preview');

        // State
        let paths = []; // Stores all completed paths: { points: [], color: string, width: number }
        let currentPath = []; // Points for the current stroke
        let isDrawing = false;
        
        // Settings
        let currentColor = '#3b82f6';
        let currentLineWidth = 5;
        let pinchThreshold = 0.08; // Distance between fingers to trigger draw
        
        // Smoothing
        let prevX = 0;
        let prevY = 0;
        
        // --- UI Functions ---

        function setColor(color) {
            currentColor = color;
            brushPreview.style.backgroundColor = color;
        }

        function setLineWidth(width) {
            currentLineWidth = parseInt(width);
            brushPreview.style.width = Math.max(8, currentLineWidth * 2) + 'px';
            brushPreview.style.height = Math.max(8, currentLineWidth * 2) + 'px';
        }

        function clearCanvas() {
            paths = [];
            currentPath = [];
        }

        // --- Drawing Logic ---

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        function onResults(results) {
            // Update Canvas Size to match window
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;

            // 1. Draw the Video Feed
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // MediaPipe results are not mirrored by default, but our CSS mirrors the canvas.
            // We draw the image normally.
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            // 2. Process Hand Landmarks
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // We only use the first detected hand
                const landmarks = results.multiHandLandmarks[0];

                // Finger Tips
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];

                // Calculate Distance (Pinch Detection)
                const dist = distance(indexTip, thumbTip);

                // Convert normalized coordinates (0-1) to pixel coordinates
                const x = indexTip.x * canvasElement.width;
                const y = indexTip.y * canvasElement.height;

                // Smoothing
                // If it's the first frame, just set it
                if (prevX === 0 && prevY === 0) {
                    prevX = x;
                    prevY = y;
                }
                
                // Smooth the movement to reduce jitter
                const smoothX = lerp(prevX, x, 0.5);
                const smoothY = lerp(prevY, y, 0.5);
                
                prevX = smoothX;
                prevY = smoothY;

                // Check Pinch State
                if (dist < pinchThreshold) {
                    // PINCHED: Drawing mode
                    if (!isDrawing) {
                        isDrawing = true;
                        currentPath = []; // Start new path
                    }
                    currentPath.push({ x: smoothX, y: smoothY });
                    
                    // Visual feedback: Green circle
                    canvasCtx.beginPath();
                    canvasCtx.arc(smoothX, smoothY, 15, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                    canvasCtx.fill();
                } else {
                    // RELEASED: Hover mode
                    if (isDrawing) {
                        isDrawing = false;
                        // Save the finished path
                        if (currentPath.length > 1) {
                            paths.push({
                                points: [...currentPath],
                                color: currentColor,
                                width: currentLineWidth
                            });
                        }
                    }
                    
                    // Visual feedback: White ring (cursor)
                    canvasCtx.beginPath();
                    canvasCtx.arc(smoothX, smoothY, 10, 0, 2 * Math.PI);
                    canvasCtx.strokeStyle = currentColor;
                    canvasCtx.lineWidth = 2;
                    canvasCtx.stroke();
                }
            } else {
                // Reset drawing state if hand is lost
                isDrawing = false;
                if (currentPath.length > 1) {
                    paths.push({
                         points: [...currentPath],
                         color: currentColor,
                         width: currentLineWidth
                    });
                }
                currentPath = [];
            }

            // 3. Render All Paths
            // We set lineCap to round for smoother looking lines
            canvasCtx.lineCap = 'round';
            canvasCtx.lineJoin = 'round';

            // Draw saved paths
            for (const path of paths) {
                if (path.points.length < 2) continue;
                
                canvasCtx.beginPath();
                canvasCtx.lineWidth = path.width;
                canvasCtx.strokeStyle = path.color;
                
                canvasCtx.moveTo(path.points[0].x, path.points[0].y);
                for (let i = 1; i < path.points.length; i++) {
                    canvasCtx.lineTo(path.points[i].x, path.points[i].y);
                }
                canvasCtx.stroke();
            }

            // Draw current active path (the one being drawn right now)
            if (currentPath.length > 1) {
                canvasCtx.beginPath();
                canvasCtx.lineWidth = currentLineWidth;
                canvasCtx.strokeStyle = currentColor;
                
                canvasCtx.moveTo(currentPath[0].x, currentPath[0].y);
                for (let i = 1; i < currentPath.length; i++) {
                    canvasCtx.lineTo(currentPath[i].x, currentPath[i].y);
                }
                canvasCtx.stroke();
            }

            canvasCtx.restore();
        }

        // --- Initialization ---

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Update status when loaded
        // There isn't a direct "onLoad" callback for the model, but usually once frames start processing, it's good.
        // We'll fake a small delay or wait for first result.
        let modelLoaded = false;
        const originalOnResults = hands.onResults; 

        // Camera Setup
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
                if(!modelLoaded) {
                    modelLoaded = true;
                    statusInd.innerHTML = '<div class="w-3 h-3 bg-green-500 rounded-full animate-pulse"></div><span class="text-green-400 font-semibold">Active</span>';
                }
            },
            width: 1280,
            height: 720
        });

        camera.start()
            .catch(err => {
                console.error("Camera error:", err);
                statusInd.innerHTML = '<span class="text-red-500">Camera Error. Allow permissions.</span>';
            });
            
    </script>
</body>
</html>
